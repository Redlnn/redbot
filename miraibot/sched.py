from schedule import *
import time
from graia.broadcast import Broadcast


"""

>>> import time
>>> def job():
>>>     times = time.strftime("%Y-%m-%d %a %H:%M:%S ", time.localtime())
>>>     print(f"\r现在时间是： {times}", end='')

>>> schedule.every(10).minutes.do(job)               # 每隔 10 分钟运行一次 job 函数
>>> schedule.every().hour.do(job)                    # 每隔 1 小时运行一次 job 函数
>>> schedule.every().day.at("10:30").do(job)         # 每天在 10:30 时间点运行 job 函数
>>> schedule.every().monday.do(job)                  # 每周一 运行一次 job 函数
>>> schedule.every().wednesday.at("13:15").do(job)   # 每周三 13：15 时间点运行 job 函数
>>> schedule.every().minute.at(":17").do(job)        # 每分钟的 17 秒时间点运行 job 函数

>>> try:
>>>     while True:
>>>         schedule.run_pending()
>>>         time.sleep(0.2)
>>> except KeyboardInterrupt:
>>>     pass

具体信息也可以在 https://github.com/dbader/schedule 上查看
"""

class scheduler(Scheduler):
    def run_all(self, delay_seconds=0):
        """
        Run all jobs regardless if they are scheduled to run or not.

        A delay of `delay` seconds is added between each job. This helps
        distribute system load generated by the jobs more evenly
        over time.

        :param delay_seconds: A delay added between every executed job
        """
        logger.debug('Running *all* %i jobs with %is delay inbetween',
                    len(self.jobs), delay_seconds)
        for job in self.jobs[:]:
            self._run_job(job)
            time.sleep(delay_seconds)


class Jobs(Job):
    def run(self):
        """
        Run the job and immediately reschedule it.

        :return: The return value returned by the `job_func`
        """
        logger.debug('Running job %s', self)
        ret = self.job_func()
        self.last_run = datetime.datetime.now()
        self._schedule_next_run()
        return ret


Job.run = Jobs.run
default_scheduler = scheduler()

def job():
    import time
    times = time.strftime("%Y-%m-%d %a %H:%M:%S ", time.localtime())
    print(f"\r现在时间是： {times}", end='')


async def aio_run(time: [float, int]=0.4):
    """
    计划任务循环体

    :param time: 每次循环的间隔时间, 单位 秒
    """
    from asyncio import sleep

    try:
        while True:
            run_pending()
            await sleep(time)
    except KeyboardInterrupt:
        pass


def init(loop=None):
    loop = loop or Broadcast.loop
    loop.create_task(aio_run())
    
    for i in range(60):
        if i < 10:
            every().minute.at(f":0{i}").do(job)
        else:
            every().minute.at(f":{i}").do(job)