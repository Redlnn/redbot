from schedule import *
import time
from graia.broadcast import Broadcast


"""
# **各种范例**
## 运行范例
>>> import time
>>> def job():
>>>     times = time.strftime("%Y-%m-%d %a %H:%M:%S ", time.localtime())
>>>     print(f"\r现在时间是： {times}", end='')

>>> schedule.every(10).minutes.do(job)               # 每隔 10 分钟运行一次 job 函数
>>> schedule.every().hour.do(job)                    # 每隔 1 小时运行一次 job 函数
>>> schedule.every().day.at("10:30").do(job)         # 每天在 10:30 时间点运行 job 函数
>>> schedule.every().monday.do(job)                  # 每周一 运行一次 job 函数
>>> schedule.every().wednesday.at("13:15").do(job)   # 每周三 13：15 时间点运行 job 函数
>>> schedule.every().minute.at(":17").do(job)        # 每分钟的 17 秒时间点运行 job 函数

>>> try:
>>>     while True:
>>>         schedule.run_pending()
>>>         time.sleep(0.2)
>>> except KeyboardInterrupt:
>>>     pass



## 只跑一次的任务
>>> def job_that_executes_once():
>>>     # Do some work ...
>>>     return schedule.CancelJob

>>> schedule.every().day.at('22:30').do(job_that_executes_once)



## 取消多个任务
>>> # 通过 tag 函数给它们添加唯一标识符进行分组，取消时通过标识符进行取消相应组的任务
>>> def greet(name):
>>>     print('Hello {}'.format(name))

>>> schedule.every().day.do(greet, 'Andrea').tag('daily-tasks', 'friend')
>>> schedule.every().hour.do(greet, 'John').tag('hourly-tasks', 'friend')
>>> schedule.every().hour.do(greet, 'Monica').tag('hourly-tasks', 'customer')
>>> schedule.every().day.do(greet, 'Derek').tag('daily-tasks', 'guest')

>>> schedule.clear('daily-tasks')



## 给任务传递函数
>>> def greet(name):
>>>     print('Hello', name)

>>> schedule.every(2).seconds.do(greet, name='Alice')
>>> schedule.every(4).seconds.do(greet, name='Bob')



# **说明**
目前该调度器暂时不处理任何异常，一旦发生异常会导致整个调度器挂掉。
因此建议在使用时充分考虑各种情况。

具体信息也可以在 https://github.com/dbader/schedule 上查看
想要更详细的使用方法? 推荐看看 https://www.jianshu.com/p/57d09d3c8998
"""

class scheduler(Scheduler):
    def run_all(self, delay_seconds=0):
        """
        Run all jobs regardless if they are scheduled to run or not.

        A delay of `delay` seconds is added between each job. This helps
        distribute system load generated by the jobs more evenly
        over time.

        :param delay_seconds: A delay added between every executed job
        """
        logger.debug('Running *all* %i jobs with %is delay inbetween',
                    len(self.jobs), delay_seconds)
        for job in self.jobs[:]:
            self._run_job(job)
            time.sleep(delay_seconds)


class Jobs(Job):
    def run(self):
        """
        Run the job and immediately reschedule it.

        :return: The return value returned by the `job_func`
        """
        logger.debug('Running job %s', self)
        ret = self.job_func()
        self.last_run = datetime.datetime.now()
        self._schedule_next_run()
        return ret


Job.run = Jobs.run
default_scheduler = scheduler()

def job():
    import time
    times = time.strftime("%Y-%m-%d %a %H:%M:%S ", time.localtime())
    print(f"\r现在时间是： {times}", end='')


async def aio_run(time: [float, int]=0.4):
    """
    计划任务循环体

    :param time: 每次循环的间隔时间, 单位 秒
    """
    from asyncio import sleep

    try:
        while True:
            run_pending()
            await sleep(time)
    except KeyboardInterrupt:
        pass


def init(loop=None):
    loop = loop or Broadcast.loop
    loop.create_task(aio_run())
    
    for i in range(60):
        if i < 10:
            every().minute.at(f":0{i}").do(job)
        else:
            every().minute.at(f":{i}").do(job)